{
  "hash": "8947b41459bbb3b911c85f25c1e8076c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'VPIN: A Python-Based Example'\nformat: html\n---\n\nEasley, Lopez de Prado, and O'Hara (2012) introduce the VPIN metric, a tool designed to gauge order flow toxicity in high-frequency trading scenarios. VPIN is rooted in the Probability of Informed Trading (PIN) model, a microstructure model that frames trading as a dynamic interaction between liquidity providers and traders. The PIN model discerns the rate of uninformed order flow by analyzing the standard levels of buying and selling in a stock. Any deviations from this norm are then attributed to information-based trading. The crux of this model lies in PIN, representing the likelihood of an order originating from an informed trader.\n\nVPIN is essentially a high-frequency market-tailored version of PIN. It's updated in volume time, ensuring each interval has a consistent trade volume, a metric deemed more pertinent than clock time in high-frequency trading. VPIN's estimation is direct and analytical, bypassing the need for intermediate numerical estimations or complex parameters.\n\n#### Python Implementation of VPIN\n\nThe calculation of VPIN involves several key steps:\n\n1.  **Data Preparation:**\n    *   **Order Book and Trade Data:** This step involves acquiring high-frequency order book and trade data for the asset under scrutiny. This dataset should encompass timestamps, prices, and volumes for both bids and asks, along with details of executed trades.\n    *   **Trade Classification:** Each trade is then categorized as either a buy or sell. While the authors suggest a \"bulk volume classification\" technique, simpler methods like the tick rule can suffice.\n\n2.  **Volume Bucketing:**\n    *   **Define Bucket Size (V):** A bucket size is determined, representing the aggregate volume of trades to be included in each bucket. The authors recommend using 1/50th of the average daily volume.\n    *   **Aggregate Trades:** Trades are sequentially grouped into buckets until the cumulative volume within a bucket matches the predefined size (V).\n\n3.  **Calculate Order Imbalance (OI):**\n    *   For each bucket, the order imbalance (OI) is computed as the discrepancy between buy volume (Vb) and sell volume (Vs), normalized by the total volume (V):\n\n$$\nOI = (V_b - V_s) / V\n$$\n\n4.  **Calculate VPIN:**\n    *   **Choose Sample Length (n):** The number of buckets to be factored into the VPIN calculation is decided. The authors employ n = 50, roughly equivalent to one trading day.\n    *   **Calculate VPIN:** VPIN is calculated as the sum of absolute order imbalances across the 'n' buckets, divided by the total volume across these 'n' buckets:\n\n$$\nVPIN = (|OI_1| + |OI_2| + ... + |OI_n|) / (n * V)\n$$\n\n#### Python Code Example\n\n::: {#978bf66a .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\n# Simulate Order Book and Trade Data\nnp.random.seed(42)\nnum_trades = 1000\nprices = np.random.normal(100, 5, num_trades)\nvolumes = np.random.randint(1, 10, num_trades)\ntrade_types = np.random.choice([\"buy\", \"sell\"], num_trades)\ndata = pd.DataFrame({\"price\": prices, \"volume\": volumes, \"trade_type\": trade_types})\n\n# Volume Bucketing\nbucket_size = 50  # Example bucket size\ndata[\"cumulative_volume\"] = data[\"volume\"].cumsum()\ndata[\"bucket\"] = data[\"cumulative_volume\"] // bucket_size\n\n# Calculate Order Imbalance\norder_imbalance = data.groupby(\"bucket\").apply(\n    lambda x: (x[x[\"trade_type\"] == \"buy\"][\"volume\"].sum() - x[x[\"trade_type\"] == \"sell\"][\"volume\"].sum()) / x[\"volume\"].sum()\n)\n\n# Calculate VPIN\nsample_length = 10  # Example sample length\nvpin = order_imbalance.rolling(window=sample_length).apply(lambda x: np.abs(x).sum() / (sample_length * bucket_size))\n\nprint(vpin.tail(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbucket\n91     0.010214\n92     0.009342\n93     0.007675\n94     0.007918\n95     0.006875\n96     0.006680\n97     0.006389\n98     0.005828\n99     0.005056\n100    0.005033\ndtype: float64\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/yd/rdwvt_yn6xv6m26pmptqyh6r0000gp/T/ipykernel_52168/1889314537.py:18: DeprecationWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  order_imbalance = data.groupby(\"bucket\").apply(\n```\n:::\n:::\n\n\n#### Explanation of the Code\n\n1.  **Simulate Data:** Random price, volume, and trade type data are generated to mimic a high-frequency trading scenario.\n2.  **Volume Bucketing:** Buckets are formed based on cumulative volume, and each trade is assigned to its respective bucket.\n3.  **Calculate Order Imbalance:** The data is grouped by bucket, and the order imbalance is calculated for each.\n4.  **Calculate VPIN:** A rolling window is employed to compute VPIN using the specified sample length.\n\n#### Key Considerations\n\n*   This example is a simplified illustration. Real-world applications would necessitate actual high-frequency data and a more refined trade classification methodology.\n*   The selection of bucket size and sample length can significantly influence the VPIN calculation.\n*   VPIN is a relative metric, and its interpretation hinges on the specific asset and prevailing market conditions.\n\n",
    "supporting": [
      "VPIN: A Python-Based Example_files"
    ],
    "filters": [],
    "includes": {}
  }
}